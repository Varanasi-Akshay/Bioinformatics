flavors_of_cacao_new
library(knitr)
opts_chunk$set(fig.align = "center", fig.height = 5, fig.width = 6)
library(tidyverse)
theme_set(theme_bw(base_size = 12))
library(ggthemes)
flavors_of_cacao <-
read_csv("https://raw.githubusercontent.com/clauswilke/dviz.supp/master/data-raw/cacao/cacao_clean.csv") %>%
extract(cocoa_percent, "cocoa_percent", regex = "([^%]+)%", convert = TRUE)
head(flavors_of_cacao)
flavors_of_cacao %>%
group_by(company, location) %>%
summarize(number_reviews = n(), min_rate = min(rating), max_rate = max(rating)) %>%
filter(number_reviews >= 20) %>%
arrange(number_reviews)-> flavors_of_cacao_new
flavors_of_cacao_new
flavors_of_cacao_new %>% group_by(location) %>% summarize(min_rate = min(min_rate), max_rate = max(max_rate))
flavors_of_cacao_new
fit<-lm(max_rate~number_reviews,data=ToothGrowth)
flavors_of_cacao_new
fit<-lm(max_rate~number_reviews,data=ToothGrowth)
flavors_of_cacao_new
fit<-lm(max_rate~number_reviews,data=flavors_of_cacao_new)
anova(fit)
flavors_of_cacao_new
fit<-lm(max_rate~number_reviews,data=flavors_of_cacao_new)
anova(fit)
fit<-lm(min_rate~number_reviews,data=flavors_of_cacao_new)
anova(fit)
flavors_of_cacao %>%
group_by(location) %>%
summarize(number_reviews = n(), min_rate = min(rating), max_rate = max(rating)) ->flavors_of_cacao_location
library(knitr)
opts_chunk$set(fig.align = "center", fig.height = 5, fig.width = 6)
library(tidyverse)
theme_set(theme_bw(base_size = 12))
library(ggthemes)
flavors_of_cacao <-
read_csv("https://raw.githubusercontent.com/clauswilke/dviz.supp/master/data-raw/cacao/cacao_clean.csv") %>%
extract(cocoa_percent, "cocoa_percent", regex = "([^%]+)%", convert = TRUE)
head(flavors_of_cacao)
flavors_of_cacao %>%
group_by(location) %>%
summarize(number_reviews = n(), min_rate = min(rating), max_rate = max(rating)) ->flavors_of_cacao_location
#counts the number of reviews for each company location and calculates a minimum and a maximum ratings of each company location
flavors_of_cacao_location
flavors_of_cacao_location  %>%
group_by(location) %>%
filter(sum(number_reviews) > 20) %>%
arrange(desc(number_reviews))-> flavors_of_cacao_new
flavors_of_cacao_new
tail(flavors_of_cacao_new)
flavors_of_cacao_new  %>%
filter(max_rate==max(flavors_of_cacao_new$max_rate))
flavors_of_cacao_new  %>%
filter(min_rate==min(flavors_of_cacao_new$min_rate))
flavors_of_cacao %>%
filter(location == 'Italy') -> italy
flavors_of_cacao %>%
filter(location == 'Belgium') -> belgium
t.test(italy$rating,belgium$rating)
# Untidy dataset
flavors_of_cacao_new
# Since there are two columns min rate and max rate which is acutually a variable so there should be one column saying whether it is max or min. There should be another column with the value of ratings.
# convert to tidy dataset
flavors_of_cacao_new %>%
gather(min_max,ratings,min_rate:max_rate)-> flavors_of_cacao_tidy
flavors_of_cacao_tidy
ggplot(flavors_of_cacao_tidy, aes(x=number_reviews, y=ratings, color=min_max))+geom_point()
# fit<-lm(max_rate~number_reviews,data=flavors_of_cacao_new)
# anova(fit)
#
# fit<-lm(min_rate~number_reviews,data=flavors_of_cacao_new)
# anova(fit)
flavors_of_cacao #%>%
flavors_of_cacao
ggplot(flavors_of_cacao, aes(x=cocoa_percent, y=rating))+geom_point()+geom_smooth()
ggplot(flavors_of_cacao, aes(x=bean_origin, y=rating))+geom_point()+geom_smooth()
ggplot(flavors_of_cacao, aes(x=bean_type, y=rating))+geom_point()+geom_smooth()
(unique(flavors_of_cacao$cocoa_percent))
(unique(flavors_of_cacao$bean_origin))
(unique(flavors_of_cacao$bean_type))
(unique(flavors_of_cacao$bean_origin_detailed))
#(unique(flavors_of_cacao$bean_origin_detailed))
head(ToothGrowth)
#(unique(flavors_of_cacao$bean_origin_detailed))
flavors.mod <- lm(rating ~ bean_type, data = flavors_of_cacao)
anova(flavors.mod)
#(unique(flavors_of_cacao$bean_origin_detailed))
flavors.mod <- lm(rating ~ bean_type+bean_origins, data = flavors_of_cacao)
#(unique(flavors_of_cacao$bean_origin_detailed))
flavors.mod <- lm(rating ~ bean_type+bean_origin, data = flavors_of_cacao)
anova(flavors.mod)
#(unique(flavors_of_cacao$bean_origin_detailed))
flavors.mod <- lm(rating ~ bean_type+bean_origin+cocoa_percent, data = flavors_of_cacao)
anova(flavors.mod)
#(unique(flavors_of_cacao$bean_origin_detailed))
flavors.mod <- lm(rating ~ bean_type+bean_origin+cocoa_percent+company, data = flavors_of_cacao)
anova(flavors.mod)
fit<-lm(rating~bean_type+bean_origin+cocoa_percent+company, data=flavors_of_cacao)
summary(flavors_of_cacao)
summary(fit)
summary(fit)
anova(fit)
(unique(flavors_of_cacao$company))
#(unique(flavors_of_cacao$bean_origin_detailed))
flavors.mod <- lm(rating ~ bean_type+bean_origin+cocoa_percent+company+location, data = flavors_of_cacao)
anova(flavors.mod)
#(unique(flavors_of_cacao$bean_origin_detailed))
flavors.mod <- lm(rating ~ bean_type+cocoa_percent+company+location, data = flavors_of_cacao)
anova(flavors.mod)
library(knitr)
opts_chunk$set(fig.align = "center", fig.height = 5, fig.width = 6)
library(tidyverse)
theme_set(theme_bw(base_size = 12))
library(ggthemes)
flavors_of_cacao <-
read_csv("https://raw.githubusercontent.com/clauswilke/dviz.supp/master/data-raw/cacao/cacao_clean.csv") %>%
extract(cocoa_percent, "cocoa_percent", regex = "([^%]+)%", convert = TRUE)
head(flavors_of_cacao)
flavors_of_cacao %>%
group_by(location) %>%
summarize(number_reviews = n(), min_rate = min(rating), max_rate = max(rating)) ->flavors_of_cacao_location
#counts the number of reviews for each company location and calculates a minimum and a maximum ratings of each company location
flavors_of_cacao_location
flavors_of_cacao_location  %>%
group_by(location) %>%
filter(sum(number_reviews) > 20) %>%
arrange(desc(number_reviews))-> flavors_of_cacao_new
flavors_of_cacao_new
tail(flavors_of_cacao_new)
flavors_of_cacao_new  %>%
filter(max_rate==max(flavors_of_cacao_new$max_rate))
flavors_of_cacao_new  %>%
filter(min_rate==min(flavors_of_cacao_new$min_rate))
flavors_of_cacao %>%
filter(location == 'Italy') -> italy
flavors_of_cacao %>%
filter(location == 'Belgium') -> belgium
t.test(italy$rating,belgium$rating)
# Prints out the Untidy dataset
flavors_of_cacao_new
# Since there are two columns min rate and max rate which is acutually a variable so there should be one column saying whether it is max or min. There should be another column with the value of ratings.
# convert to tidy dataset
flavors_of_cacao_new %>%
gather(min_max,ratings,min_rate:max_rate)-> flavors_of_cacao_tidy
# Prints out the tidy dataset
flavors_of_cacao_tidy
ggplot(flavors_of_cacao_tidy, aes(x=number_reviews, y=ratings, color=min_max))+geom_point()
head(flavors_of_cacao)
flavors_of_cacao
ggplot(flavors_of_cacao, aes(x=cocoa_percent, y=rating))+geom_point()+geom_smooth()
(unique(flavors_of_cacao$cocoa_percent))
ggplot(flavors_of_cacao, aes(x=bean_origin, y=rating))+geom_point()+geom_smooth()
(unique(flavors_of_cacao$bean_origin))
#(unique(flavors_of_cacao$bean_origin_detailed))
flavors.mod <- lm(rating ~ location, data = flavors_of_cacao)
anova(flavors.mod)
library(knitr)
opts_chunk$set(fig.align = "center", fig.height = 4, fig.width = 5)
library(tidyverse)
theme_set(theme_bw(base_size = 12))
library(plotROC)
library(ggthemes)
head(mtcars)
# model to use:
# am ~ hp + mpg
# Making logistic regression model for the above model.
glm_model1 <-glm(
am ~ hp + mpg,
data = mtcars,
family = binomial
)
# Summary of the model 1
summary(glm_model1)
# model to use:
# am ~ hp
# Making logistic regression model for the above model.
glm_model2 <-glm(
am ~ hp,
data = mtcars,
family = binomial
)
# Summary of the model 2
summary(glm_model2)
# results data frame for model 1
df_model1 <- data.frame(
predictor = predict(glm_model1, mtcars),
known_truth = mtcars$am,
data_name = "Model 1"
)
# results data frame for model 2
df_model2 <- data.frame(
predictor = predict(glm_model2, mtcars),
known_truth = mtcars$am,
data_name = "Model 2"
)
df_combined <-rbind(df_model1,df_model2)
ggplot(df_combined, aes(d = known_truth, m = predictor, color = data_name)) +
geom_roc(n.cuts = 0) +
scale_color_colorblind()
p<-ggplot(df_combined, aes(d = known_truth, m = predictor, color = data_name)) +
geom_roc(n.cuts = 0)
calc_auc(p)
left_join(data_info, calc_auc(p)) %>%
select(-group, -PANEL) %>%
arrange(desc(AUC))
p<-ggplot(df_combined, aes(d = known_truth, m = predictor, color = data_name)) +
geom_roc(n.cuts = 0)
calc_auc(p)
data_name <- unique(df_combined$data_name)
data_name
data_info <- data.frame(
data_name,
group = order(data_name)
)
data_info
left_join(data_info, calc_auc(p)) %>%
select(-group, -PANEL) %>%
arrange(desc(AUC))
# Calculating Area under the curve for models
p<-ggplot(df_combined, aes(d = known_truth, m = predictor, color = data_name)) +
geom_roc(n.cuts = 0)
data_name <- unique(df_combined$data_name)
data_name
data_info <- data.frame(
data_name,
group = order(data_name)
)
left_join(data_info, calc_auc(p)) %>%
select(-group, -PANEL) %>%
arrange(desc(AUC))
# Calculating Area under the curve for models
p<-ggplot(df_combined, aes(d = known_truth, m = predictor, color = data_name)) +
geom_roc(n.cuts = 0)
data_name <- unique(df_combined$data_name)
data_name
data_info <- data.frame(
data_name,
group = order(data_name)
)
left_join(data_info, calc_auc(p)) %>%
select(-group, -PANEL) %>%
arrange(desc(AUC))
library(knitr)
opts_chunk$set(fig.align = "center", fig.height = 4, fig.width = 5)
library(tidyverse)
theme_set(theme_bw(base_size = 12))
library(plotROC)
library(ggthemes)
head(mtcars)
# model to use:
# am ~ hp + mpg
# Making logistic regression model for the above model.
glm_model1 <-glm(
am ~ hp + mpg,
data = mtcars,
family = binomial
)
# Summary of the model 1
summary(glm_model1)
# model to use:
# am ~ hp
# Making logistic regression model for the above model.
glm_model2 <-glm(
am ~ hp,
data = mtcars,
family = binomial
)
# Summary of the model 2
summary(glm_model2)
# results data frame for model 1
df_model1 <- data.frame(
predictor = predict(glm_model1, mtcars),
known_truth = mtcars$am,
data_name = "Model 1"
)
# results data frame for model 2
df_model2 <- data.frame(
predictor = predict(glm_model2, mtcars),
known_truth = mtcars$am,
data_name = "Model 2"
)
# Combining both the dataframes to plot ROC curves
df_combined <-rbind(df_model1,df_model2)
# Plotting the ROC curve for both the Models
ggplot(df_combined, aes(d = known_truth, m = predictor, color = data_name)) +
geom_roc(n.cuts = 0) +
scale_color_colorblind()
# Calculating Area under the curve for models
p<-ggplot(df_combined, aes(d = known_truth, m = predictor, color = data_name)) +
geom_roc(n.cuts = 0)
data_name <- unique(df_combined$data_name)
data_name
data_info <- data.frame(
data_name,
group = order(data_name)
)
left_join(data_info, calc_auc(p)) %>%
select(-group, -PANEL) %>%
arrange(desc(AUC))
train_fraction <- 0.5 # fraction of data for training purposes
set.seed(123) # set the seed to make the partition reproductible
train_size <- floor(train_fraction * nrow(mtcars)) # number of observations in training set
train_indices <- sample(1:nrow(mtcars), size = train_size)
train_data <- mtcars[train_indices, ] # get training data
test_data <- mtcars[-train_indices, ] # get test data
# model to use:
# am ~ hp + mpg
# Making logistic regression model for the above model. (This time we use training data only)
glm_model <-glm(
am ~ hp + mpg,
data = train_data, # Here we give only the training data instead of whole dataset
family = binomial
)
# results data frame for training data
df_train <- data.frame(
predictor = predict(glm_model, train_data),
known_truth = train_data$am,
data_name = "training"
)
# results data frame for testing data
df_test <- data.frame(
predictor = predict(glm_model, test_data),
known_truth = test_data$am,
data_name = "test"
)
df_combined <-rbind(df_train,df_test)
ggplot(df_combined, aes(d = known_truth, m = predictor, color = data_name)) +
geom_roc(n.cuts = 0) +
#xlim(0, 0.14) +
scale_color_colorblind()
# results data frame for testing data
df_test <- data.frame(
predictor = predict(glm_model, test_data),
known_truth = factor(test_data$am),
data_name = "test"
)
# Density plot
ggplot(df_test, aes(x = predictor, fill = known_truth )) +
geom_density(alpha = .5) +scale_fill_colorblind()
# Calculating Area under the curve for models
p<-ggplot(df_combined, aes(d = known_truth, m = predictor, color = data_name)) +
geom_roc(n.cuts = 0)
data_name <- unique(df_combined$data_name)
data_name
data_info <- data.frame(
data_name,
group = order(data_name)
)
left_join(data_info, calc_auc(p)) %>%
select(-group, -PANEL) %>%
arrange(desc(AUC))
# model to use:
# am ~ hp + mpg
# Making logistic regression model for the above model. (This time we use training data only)
glm_model <-glm(
am ~ hp + mpg,
data = train_data, # Here we give only the training data instead of whole dataset
family = binomial
)
# results data frame for training data
df_train <- data.frame(
predictor = predict(glm_model, train_data),
known_truth = factor(train_data$am),
data_name = "training"
)
# results data frame for testing data
df_test <- data.frame(
predictor = predict(glm_model, test_data),
known_truth = factor(test_data$am),
data_name = "test"
)
df_combined <-rbind(df_train,df_test)
ggplot(df_combined, aes(d = known_truth, m = predictor, color = data_name)) +
geom_roc(n.cuts = 0) +
#xlim(0, 0.14) +
scale_color_colorblind()
# model to use:
# am ~ hp + mpg
# Making logistic regression model for the above model. (This time we use training data only)
glm_model <-glm(
am ~ hp + mpg,
data = train_data, # Here we give only the training data instead of whole dataset
family = binomial
)
# results data frame for training data
df_train <- data.frame(
predictor = predict(glm_model, train_data),
known_truth = train_data$am,
data_name = "training"
)
# results data frame for testing data
df_test <- data.frame(
predictor = predict(glm_model, test_data),
known_truth = test_data$am,
data_name = "test"
)
df_combined <-rbind(df_train,df_test)
ggplot(df_combined, aes(d = known_truth, m = predictor, color = data_name)) +
geom_roc(n.cuts = 0) +
#xlim(0, 0.14) +
scale_color_colorblind()
# results data frame for training data
df_train <- data.frame(
predictor = predict(glm_model, train_data),
known_truth = factor(train_data$am),
data_name = "training"
)
# Density plot
ggplot(df_train, aes(x = predictor, fill = known_truth )) +
geom_density(alpha = .5) +scale_fill_colorblind()
